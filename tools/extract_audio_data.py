#!/usr/bin/env python3
"""
Script to extract audio data definitions from headers and create a single source file.
This fixes the multiple definition errors by moving definitions out of headers.
"""

import os
import re
from pathlib import Path

def extract_audio_data(header_file):
    """Extract the implementation section from an audio header file."""
    with open(header_file, 'r') as f:
        content = f.read()
    
    # Find the implementation section
    impl_start = content.find('// Implementation\nnamespace Exterminate {\nnamespace Audio {\n\n')
    if impl_start == -1:
        print(f"Warning: No implementation section found in {header_file}")
        return "", "", {}
    
    # Find the closing braces
    impl_end = content.rfind('} // namespace Audio\n} // namespace Exterminate')
    if impl_end == -1:
        print(f"Warning: Could not find end of implementation in {header_file}")
        return "", "", {}
    
    # Extract the implementation content (skip the namespace opening)
    impl_content = content[impl_start + len('// Implementation\nnamespace Exterminate {\nnamespace Audio {\n\n'):impl_end]
    
    # Extract audio file number from filename
    match = re.search(r'(\d{5})\.h$', header_file)
    if not match:
        print(f"Warning: Could not extract audio number from {header_file}")
        return "", "", {}
    
    audio_num = match.group(1)
    
    # Extract constants from the implementation
    constants = {}
    const_patterns = [
        (f'AUDIO_{audio_num}_SAMPLE_COUNT', r'const size_t AUDIO_' + audio_num + r'_SAMPLE_COUNT = (\d+);'),
        (f'AUDIO_{audio_num}_BYTE_SIZE', r'const size_t AUDIO_' + audio_num + r'_BYTE_SIZE = (\d+);'),
        (f'AUDIO_{audio_num}_SAMPLE_RATE', r'const uint32_t AUDIO_' + audio_num + r'_SAMPLE_RATE = (\d+);'),
        (f'AUDIO_{audio_num}_CHANNELS', r'const uint8_t AUDIO_' + audio_num + r'_CHANNELS = (\d+);'),
        (f'AUDIO_{audio_num}_BIT_DEPTH', r'const uint8_t AUDIO_' + audio_num + r'_BIT_DEPTH = (\d+);'),
    ]
    
    for const_name, pattern in const_patterns:
        match = re.search(pattern, impl_content)
        if match:
            constants[const_name] = match.group(1)
    
    return audio_num, impl_content, constants

def main():
    # Find the workspace root
    script_dir = Path(__file__).parent
    workspace_root = script_dir.parent
    audio_dir = workspace_root / 'include' / 'audio'
    
    if not audio_dir.exists():
        print(f"Error: Audio directory not found at {audio_dir}")
        return
    
    print("Extracting audio data from headers...")
    
    # Find all audio header files
    audio_files = sorted(audio_dir.glob('*.h'))
    audio_files = [f for f in audio_files if re.match(r'.*\d{5}\.h$', str(f))]
    
    print(f"Found {len(audio_files)} audio header files")
    
    # Generate the new source file content
    source_content = '''// Audio data definitions for Exterminate project
// This file contains the actual definitions of all audio data
// The headers only contain extern declarations to avoid multiple definition errors
// 
// Auto-generated by tools/extract_audio_data.py - DO NOT EDIT MANUALLY

#include <cstdint>
#include <cstddef>

namespace Exterminate {
namespace Audio {

'''
    
    # Extract data from each audio file
    for audio_file in audio_files:
        print(f"Processing {audio_file.name}...")
        audio_num, impl_content, constants = extract_audio_data(str(audio_file))
        
        if audio_num and impl_content:
            source_content += f"// Audio {audio_num} definitions\n"
            source_content += impl_content
            source_content += "\n"
    
    source_content += '''} // namespace Audio
} // namespace Exterminate
'''
    
    # Write the new source file
    output_file = workspace_root / 'src' / 'AudioData.cpp'
    with open(output_file, 'w') as f:
        f.write(source_content)
    
    print(f"Generated {output_file}")
    print(f"File size: {len(source_content)} characters")

if __name__ == '__main__':
    main()
