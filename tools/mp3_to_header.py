#!/usr/bin/env python3
"""
MP3 to C++ Header Converter
Converts MP3 files to C++ header files with embedded byte arrays.
"""

import os
import sys
import argparse
from pathlib import Path

def sanitize_variable_name(filename):
    """Convert filename to a valid C++ variable name."""
    # Remove extension and convert to valid identifier
    name = Path(filename).stem
    # Replace invalid characters with underscores
    sanitized = ''.join(c if c.isalnum() else '_' for c in name)
    # Ensure it doesn't start with a number
    if sanitized[0].isdigit():
        sanitized = 'audio_' + sanitized
    return sanitized.upper()

def mp3_to_header(mp3_path, output_dir):
    """Convert a single MP3 file to a C++ header file."""
    mp3_file = Path(mp3_path)
    if not mp3_file.exists():
        print(f"Error: {mp3_path} does not exist")
        return False
    
    # Read MP3 file as binary
    with open(mp3_file, 'rb') as f:
        mp3_data = f.read()
    
    # Generate variable name
    var_name = sanitize_variable_name(mp3_file.name)
    
    # Create header filename
    header_name = f"{mp3_file.stem}.h"
    header_path = Path(output_dir) / header_name
    
    # Ensure output directory exists
    header_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Generate C++ header content
    header_content = f"""#pragma once

// Auto-generated from {mp3_file.name}
// DO NOT EDIT - Generated by tools/mp3_to_header.py

#include <cstdint>
#include <cstddef>

namespace Exterminate {{
namespace Audio {{

// Audio data for {mp3_file.name}
extern const uint8_t {var_name}_DATA[];
extern const size_t {var_name}_SIZE;

}} // namespace Audio
}} // namespace Exterminate

// Implementation
namespace Exterminate {{
namespace Audio {{

const uint8_t {var_name}_DATA[] = {{
"""
    
    # Add binary data as hex bytes (16 per line for readability)
    for i in range(0, len(mp3_data), 16):
        chunk = mp3_data[i:i+16]
        hex_bytes = ', '.join(f'0x{byte:02X}' for byte in chunk)
        header_content += f"    {hex_bytes}"
        if i + 16 < len(mp3_data):
            header_content += ","
        header_content += "\n"
    
    header_content += f"""}};

const size_t {var_name}_SIZE = {len(mp3_data)};

}} // namespace Audio
}} // namespace Exterminate
"""
    
    # Write header file
    with open(header_path, 'w') as f:
        f.write(header_content)
    
    print(f"Generated: {header_path} ({len(mp3_data):,} bytes)")
    return True

def generate_audio_index(mp3_files, output_dir):
    """Generate an index header that includes all audio files."""
    index_path = Path(output_dir) / "audio_index.h"
    
    content = f"""#pragma once

// Auto-generated audio index
// DO NOT EDIT - Generated by tools/mp3_to_header.py

#include <cstdint>
#include <cstddef>

"""
    
    # Include all individual headers
    for mp3_file in mp3_files:
        header_name = f"{Path(mp3_file).stem}.h"
        content += f'#include "{header_name}"\n'
    
    content += f"""
namespace Exterminate {{
namespace Audio {{

// Audio file registry
struct AudioFile {{
    const char* name;
    const uint8_t* data;
    size_t size;
}};

// Available audio files
extern const AudioFile AUDIO_FILES[];
extern const size_t AUDIO_FILE_COUNT;

// Audio file indices
enum class AudioIndex : size_t {{
"""
    
    # Add enum values
    for i, mp3_file in enumerate(mp3_files):
        var_name = sanitize_variable_name(Path(mp3_file).name)
        content += f"    {var_name} = {i},\n"
    
    content += f"""    COUNT = {len(mp3_files)}
}};

}} // namespace Audio
}} // namespace Exterminate

// Implementation
namespace Exterminate {{
namespace Audio {{

const AudioFile AUDIO_FILES[] = {{
"""
    
    # Add audio file entries
    for mp3_file in mp3_files:
        var_name = sanitize_variable_name(Path(mp3_file).name)
        filename = Path(mp3_file).name
        content += f'    {{"{filename}", {var_name}_DATA, {var_name}_SIZE}},\n'
    
    content += f"""}};

const size_t AUDIO_FILE_COUNT = {len(mp3_files)};

}} // namespace Audio
}} // namespace Exterminate
"""
    
    with open(index_path, 'w') as f:
        f.write(content)
    
    print(f"Generated: {index_path}")

def main():
    parser = argparse.ArgumentParser(description='Convert MP3 files to C++ headers')
    parser.add_argument('input_dir', help='Directory containing MP3 files')
    parser.add_argument('output_dir', help='Directory for generated header files')
    parser.add_argument('--pattern', default='*.mp3', help='File pattern to match (default: *.mp3)')
    
    args = parser.parse_args()
    
    input_path = Path(args.input_dir)
    output_path = Path(args.output_dir)
    
    if not input_path.exists():
        print(f"Error: Input directory {input_path} does not exist")
        return 1
    
    # Find all MP3 files
    mp3_files = list(input_path.glob(args.pattern))
    mp3_files.sort()  # Sort for consistent ordering
    
    if not mp3_files:
        print(f"No MP3 files found in {input_path}")
        return 1
    
    print(f"Found {len(mp3_files)} MP3 files")
    
    # Convert each MP3 to header
    success_count = 0
    for mp3_file in mp3_files:
        if mp3_to_header(mp3_file, output_path):
            success_count += 1
    
    if success_count > 0:
        # Generate index file
        generate_audio_index(mp3_files, output_path)
        print(f"Successfully converted {success_count}/{len(mp3_files)} files")
    
    return 0 if success_count == len(mp3_files) else 1

if __name__ == '__main__':
    sys.exit(main())
